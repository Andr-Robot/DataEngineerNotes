[toc]

# 面向对象概念
## 面向对象基本特征
面向对象的三个基本特征是：**封装**、**继承**、**多态**。
- **封装**：就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法，只让可信的类或者对象操作，对不可信的进行信息隐藏。
- **继承**：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承中最常使用的两个关键字是**extends（用于基本类和抽象类）和implements（用于接口）**。Java中类的继承是**单一继承**，若使用extends只允许有一个父类，使用implements则不限。
- **多态**：多态性是指允许不同子类型的对象对同一消息作出不同的响应。实现多态有二种方式：重写（Override）和重载（Overload）。
    - 重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
    - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同），返回类型可以相同也可以不同。

# Java修饰符
## 访问控制符
Java中，可以使用访问控制符来保护**对类、变量、方法和构造方法**的访问。Java 支持 4 种不同的访问权限。
- **default** (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
- **public** : 对所有类可见。使用对象：类、接口、变量、方法
- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）和接口**

访问控制修饰符 | 同一个类 | 同一个包 | 不同包的子类 | 任何地方
---|---|---|---|---
private(私有的) | ✓ | ✕	| ✕	| ✕   
default(默认的) | 	✓ | 	✓	 | ✕	 | ✕
protected(受保护的) | 	✓ | 	✓	 | ✓	 | ✕
public(公共的) | 	✓	 | ✓ | ✓ |✓

**访问控制和继承**：
- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被继承。

## 非访问修饰符
- static 修饰符，用来修饰类方法和类变量。
- final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
- abstract 修饰符，用来创建抽象类和抽象方法。
- synchronized 和 volatile 修饰符，主要用于线程的编程。
- transient 修饰符，在序列化和反序列化的时候，可以进行关键字的屏蔽。

### static 修饰符
- **静态变量**：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。**局部变量不能被声明为 static 变量**。

    ```
    public class Test {
    	static int num = 10;
    	public static void main(String[] args) {
    		Test t1 = new Test();
    		System.out.println(t1.num);
    		Test t2 = new Test();
    		System.out.println(t2.num);
    		t1.num += 1;
    		System.out.println(t2.num);
    	}
    }
    
    输出：
    10
    10
    11
    ```

- **静态方法**：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

### final 修饰符
- **final 变量**：**final 变量能被显式地初始化并且只能初始化一次**。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。
- **final 方法**：类中的 final 方法可以被子类继承，但是**不能被子类修改**。声明 final 方法的主要目的是防止该方法的内容被修改。

### abstract 修饰符
- **抽象类**：
    - **抽象类不能用来实例化对象**，声明抽象类的唯一目的是为了将来对该类进行扩充。
    - **一个类不能同时被 abstract 和 final 修饰**。**如果一个类包含抽象方法，那么该类一定要声明为抽象类**，否则将出现编译错误。
- **抽象方法**：
    - **抽象方法是一种没有任何实现的方法**，该方法的的具体实现由子类提供。
    - **抽象方法不能被声明成 final 和 static**。
    - 任何继承抽象类的子类**必须实现父类的所有抽象方法，除非该子类也是抽象类**。
    - 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。
    - **抽象方法的声明以分号结尾**，例如：`public abstract sample();`。

### synchronized 修饰符
synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

### transient 修饰符
java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

- 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。
- 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。
- 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
- transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现**Serializable接口**。
- 被transient关键字修饰的变量不再能被序列化（注意：若实现的是**Externalizable接口**，在**writeExternal方法**中进行手工指定所要序列化的变量，这与是否被transient修饰无关。），一个静态变量不管是否被transient修饰，均不能被序列化。

### volatile 修饰符
volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

# Java基本数据类型
- **bit**：位，一个二进制数据0或1，是1bit   
- **byte**：字节，存储空间的基本的单元，`1byte=8bit`   
- 一个英文占一个字节，1字母=1byte=8bit
- 一个中文占两个字节，1汉字=2byte=16bit


类型名称 | 类型定义 | 类型取值
---|---|---
boolean | 布尔值，作二元判断，1位 | true, false
byte | 8位有符号整数 | 最小值-128，最大值127
char | 16 位 Unicode 字符 | 最小值是 \u0000（即为0），最大值是 \uffff（即为65,535）
short | 16位有符号整数 | 最小值-32768，最大值32767
int | 32位有符号整数 | 最小值-2147483648（`$-2^{31}$`），最大值2147483647（`$2^{31}-1$`）
long | 64位有符号整数 | `$-2^{63}$`~(`$2^{63}-1$`)
float | 32位浮点数 | 1.4E-45~3.4028235E38
double | 64位浮点数 | 4.9E-324~1.7976931348623157E308

- 1B(Byte 字节)=8bit，
- 1KB (Kilobyte 千字节)=1024B， 
- 1MB (Megabyte 兆字节 简称“兆”)=1024KB， 
- 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB， 
- 1TB (Trillionbyte 万亿字节 太字节)=1024GB

# Java中引用传递和值传递
## 基本类型和引用类型
Java中**数据类型**分为两大类，**基本类型**和**引用类型**。
- **基本类型**包括：byte, short, int, long, char, float, double, boolean, returnAddress；
- **引用类型**包括：类类型，接口类型和**数组**。

相应的，**变量也有两种类型：基本类型和引用类型**。
- **基本类型的变量**保存原始值，即它代表的值就是**数值本身**，基本数据类型在声明时系统就给它分配空间；

    ```java
    int a;
    a=10;//正确，因为声明a时就分配了空间
    ```

- **引用类型的变量**保存引用值，"引用值"指向**内存空间的地址**，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置，引用类型的变量声明时只给变量分配了引用空间，而不分配数据空间。

    ```java
    Date a,b; //在内存开辟两个引用空间
    a = new Date();//开辟存储Date对象的数据空间，并把该空间的首地址赋给a
    b = a; //将a存储空间中的地址写到b的存储空间中
    ```
## 值传递和引用传递
**值传递**：方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，**此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值**。   

**引用传递**：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；**在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。**   
## 结论
1. 基本数据类型传值，对形参的修改不会影响实参；
2. 引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；
3. String, Integer, Double等不可变的类型特殊处理，因为没有提供自身修改的函数，**每次操作都是新生成一个对象**，所以要特殊对待，可以认为是和基本数据类型相似，传值操作，最后的不会修改实参对象。

# 抽象类和接口区别
## 对比
参数 | 抽象类 | 接口
---|---|---
默认的方法实现 | 它可以有默认的方法实现 | 接口完全是抽象的。它根本不存在方法的实现
实现 | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现
构造器 | 抽象类可以有构造器 | 接口不能有构造器 
与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 | 接口是完全不同的类型
访问修饰符 | 抽象方法可以有**public**、**protected**和**private**这些修饰符 | 
main方法 | 抽象方法可以有main方法并且我们可以运行它 | 接口没有main方法，因此我们不能运行它。
多继承 | 抽象方法可以继承一个类和实现多个接口 | 接口只可以继承一个或多个其它接口
速度 | 它比接口速度要快 | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法 | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。

## 什么时候使用抽象类和接口
- **如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类**。
- **如果你想实现多重继承，那么你必须使用接口**。由于**Java不支持多继承**，子类不能够继承多个类，但可以实现多个接口。
- **如果基本功能在不断改变，那么就需要使用抽象类**。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

# Java标准输入

```java
public static void main(String[] args) {
	Scanner in = new Scanner(System.in);
	System.out.print("请输入第一个字符串：");  
	String s1=in.nextLine(); 
	System.out.println("输入的字符串是："+s1);
	
	System.out.print("请输入第二个字符串："); 
	String s2=in.next(); 
	System.out.println("输入的字符串是："+s2);
}

输出：
请输入第一个字符串：      home
输入的字符串是：      home
请输入第二个字符串：      home       
输入的字符串是：home
```

## Java中.next（）和.nextLine（）的区别
参见[Java中.next（）和.nextLine（）的区别](https://blog.csdn.net/Android_DEPON/article/details/69669160)     
- nextLine（）方法返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的。结束符只是Enter键。
- next（）会自动消去有效字符前的空格，只返回输入的字符，不能得到带空格的字符串。在输入有效字符之后，将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。

**注意：** 

```java
public static void main(String[] args) {
	Scanner in = new Scanner(System.in);
	System.out.print("请输入第一个字符串：");  
	String s1=in.next(); 
	System.out.println("输入的字符串是："+s1);
	
	System.out.print("请输入第二个字符串："); 
	String s2=in.nextLine(); 
	System.out.println("输入的字符串是："+s2);
}

输出：
请输入第一个字符串：     sdafs  
输入的字符串是：sdafs
请输入第二个字符串：输入的字符串是：  
```

`nextLine()`自动读取了被`next()`去掉的Enter作为他的结束符，所以没办法从键盘输入值。其他的`next`的方法，如`nextDouble()`，`nextFloat()`，`nextInt()` 等与`nextLine()`连用时都存在这个问题。

**解决的办法是：**     
在每一个`next()`、`nextDouble()`、`nextFloat()`、`nextInt()` 等语句之后加一个`nextLine()`语句，将被`next()`去掉的Enter结束符过滤掉。

# 参考文献
[Java 重写(Override)与重载(Overload)](http://www.runoob.com/java/java-override-overload.html)     
[Java 修饰符](http://www.runoob.com/java/java-modifier-types.html#protected-desc)     
[Java transient关键字使用小记](http://www.cnblogs.com/lanxuezaipiao/p/3369962.html)
[在Java中如何使用transient](http://www.importnew.com/12611.html)