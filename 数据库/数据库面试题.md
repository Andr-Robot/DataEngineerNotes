* [为何数据库索引选用B+树，而不选二叉树](#为何数据库索引选用b树而不选二叉树)
    * [参考文献](#参考文献)
* [truncate、drop和delete的区别](#truncatedrop和delete的区别)
    * [Delete](#delete)
    * [Drop](#drop)
    * [Truncate](#truncate)
* [数据库索引建立太多会怎么样？多少合适？](#数据库索引建立太多会怎么样多少合适)
* [聚簇索引和非聚簇索引的区别](#聚簇索引和非聚簇索引的区别)

# 为何数据库索引选用B+树，而不选二叉树
实现索引时使用B+ Tree而不是二叉查找树，关键因素是**磁盘IO的次数**。   

数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，**这里的磁盘页就对应索引树的节点**。   

从二叉树的查找过程了来看，**最坏的情况下磁盘IO的次数由树的高度来决定**。为了提升搜索效率，就需要**减少磁盘IO的次数就必须要压缩树的高度**，**让瘦高的树尽量变成矮胖的树**，所以B+ Tree就在这样伟大的时代背景下诞生了。相同数量的key在B树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。

**B-Tree 和B+ Tree对比**：   
- B-Tree的每个节点都有**data域（指针）**，增大了节点大小，即增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+ Tree除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。
- B+ Tree所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问。

注意：数据库索引采用B+ Tree的主要原因是 B-Tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+ Tree应运而生。B+ Tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B-Tree不支持这样的操作（或者说效率太低）。

## 参考文献
[B+树比B树更适合做文件索引的原因](https://blog.csdn.net/mine_song/article/details/63251546)   
[浅谈MySQL的B树索引与索引优化](https://juejin.im/post/5ab857675188255570060069) 

# truncate、drop和delete的区别
参见[数据库中删除语句Drop、Delete、Truncate的相同点和不同点的比较](https://blog.csdn.net/hanxuemin12345/article/details/7818662)
## Delete
用于删除表中的行（注：可以删除某一行；也可以在不删除表的情况下（即意味着表的结构、属性、索引完整）删除所有行）     
**语法：**
- 删除某一行：Delete From 表名称  Where 列名称=值
- 删除所有行： Delete From 表名称       或     Delete *  From  表名称

## Drop
用于删除表（注：将表的结构、属性、索引也会被删除。）    
**语法：** Drop  Table 表名称

## Truncate
用于删除表内的数据（注：仅删除表内的数据，不删除表本身，相当于Delete语句不写Where子句一样）    
**语法：** Truncate Table  表名称       
**注意：** 对于有主外键关系的表，**不能使用truncate**而应该使用不带where子句的delete语句，由于**truncate不记录在日志中，不能够激活触发器**

# 数据库索引建立太多会怎么样？多少合适？
1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，维护索引要耗费时间，这种时间随着数据量的增加而增加。
2. 索引需要占物理空间。

# 聚簇索引和非聚簇索引的区别
- 聚簇索引的叶子节点就是数据节点
- 而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。


